<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    <link rel="stylesheet" href="style.css">
    <script src="https://unpkg.com/vanilla-picker@2"></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/paperjs/paper.js/6feff32254b6ba077d1e56d0ecf3f40be5ca594a/dist/paper-full.js"></script>
    <script type="text/javascript" src="offset.js"></script>
</head>

<body>
    <div id="modal">
        <div id="simple-modal">
            <div id="modal-status">
                <h2 id="modal-status">Clearing Canvas</h2>
                <i id="modal-cross" class="fa-solid fa-xmark"></i>
            </div>
            <p>Are you sure you want to delete your drawing? :(</p>
            <div id="action">
                <button id="cancel-modal">Cancel</button>
                <button id="confirm-modal" confirm-action>Confirm</button>
            </div>
        </div>
    </div>

    <div id="sliding-overlay">
        <div id="hero-content">
            <h2>Welcome to Clip draw!</h2>
            <button id="begin">BEGIN</button>
        </div>
    </div>


    <div id="contain-canvas">
        <canvas id="canvas" resize></canvas>
    </div>

    <div id="control-panel">
        <h2 id="message">Input Prompt</h2>
        <form id="send-prompt">
            <input type="text" id="messageText" />
            <button>Send</button>
        </form>
        <div id="slider-controls">
            <div id="color-picker"></div>
            <div id="width-input">
                <label>Width</label>
                <input type="range" id="width-slider" value="20" min="1" max="40">
            </div>
        </div>
    </div>

    <div id="button-panel">
        <i class="fa-solid fa-pen fa-fw pen-mode" id="pen"></i>
        <i class="fa-solid fa-arrow-pointer fa-fw pen-mode" id="select"></i>
        <i class="fa-solid fa-wand-magic-sparkles fa-fw pen-mode" id="lasso"></i>
        <i class="fa-solid fa-eraser fa-fw pen-mode" id="erase"></i>
        <i class="fa-solid fa-clock-rotate-left fa-fw" id="undo"></i>
        <i class="fa-solid fa-rotate-right fa-fw" id="redo"></i>
        <i class="fa-solid fa-trash fa-fw" id="delete"></i>
    </div>


    <script type="text/javascript">
        //     const targetHeight = 224;
        // const scaleFactor = targetHeight / window.innerHeight; // scale as a square, innerHeight smaller than width
        paper.install(window);

        const modal = document.getElementById("modal");
        const canvas = document.getElementById('canvas');
        const controlPanel = document.getElementById("control-panel");
        const backgroundColor = "#FCFCFC"
        canvas.style.background = backgroundColor;
        paper.setup(canvas);

        const topLayer = new Layer(); //for drawing + erase mask

        let strokeColor = "#402f95";
        let strokeWidth = 20;
        let myPath;
        let penMode = "pen";
        let currentSelectedPath;
        undoStack = [];
        redoStack = [];
        // undoStack.push({"type": 'addPath', 'id': newPath.id});

        function getSelectedPaths() {
            return topLayer.getItems().filter(path => path.selected)
        };

        const tool = new Tool();
        tool.onMouseDown = function(event) {
            if (penMode === "select") {
                path = null;
                var hitResult = paper.project.hitTest(event.point, {
                    segments: true,
                    stroke: true,
                    // tolerance: 5
                });
                if (!hitResult) {
                    topLayer.getItems().forEach(path => {
                        console.log(path)
                        path.selected = false;
                    });
                    return;
                }
                if (hitResult) {
                    path = hitResult.item;
                    path.selected = true; //fix so that this happens with no drag but with drag it won't toggle !path.selected
                }
            }
            if (penMode === "pen") {
                myPath = new Path({
                    strokeColor: strokeColor,
                    strokeWidth: strokeWidth,
                    strokeCap: 'round',
                    strokeJoin: 'round'
                });
                myPath.add(event.point);
                myPath.add({
                    ...event.point,
                    x: event.point.x + .001 //this is ok because path gets simplified
                }); //in case no drag means no line segment
            }
        }
        tool.onMouseDrag = function(event) {
            if (penMode === "pen") {
                myPath.add(event.point);
                myPath.smooth();
            }
            if (penMode === "select") {
                const selectedPaths = getSelectedPaths(); // all selected
                console.log(selectedPaths)
                selectedPaths.forEach(path => {
                    path.position.x += event.delta.x;
                    path.position.y += event.delta.y;
                })
            }
        }
        tool.onMouseUp = function(event) {
            if (penMode === "pen") {
                myPath.simplify()
                    // myPath.onMouseDrag = (e) => {
                    //     if (myPath.selected === true && penMode === "select") { //refactor so all selected paths
                    //         myPath.position.x += e.delta.x;
                    //         myPath.position.y += e.delta.y;
                    //     }
                    // }
                console.log(paper.project.exportSVG());
                // myPath.selected = true;
                // myPath.selected = true;
                // const pathStrokes = myPath.exportSVG();
                // console.log(myPath.pathData);
                sendPaths(paper.project.exportSVG({
                    asString: true
                }));
                // console.log(paper.project.getItems()[0]._children); // is an array of paths and can get segments or pathData
                // paper.project.importSVG(svg)
                // console.log(svg)
                //draw path
                // var pathData = 'm 54.473683,133.57894 c 2.309053,6.52389 5.103384,12.88691 9.947368,18.00001 1.602465,1.69148 7.516862,3.36572 9,3.78947 8.215344,2.34724 20.231724,5.06339 28.894739,2.8421 3.21552,-0.82449 6.03091,-2.77861 9,-4.26315 8.27335,-4.13668 15.89845,-8.52099 21.31579,-16.10527';
                // var path = new Path(pathData);
                // path.strokeColor = 'red';
                // path.scale(5);
                undoStack.push({
                    type: "draw-event",
                    data: myPath
                })
            }
        }


        const eraseTool = new Tool();
        // eraseTool.minDistance = 10;
        let erasePath;
        let tmpGroup;
        let mask;

        eraseTool.onMouseDown = function(event) {
            erasePath = new Path({
                strokeWidth: strokeWidth * paper.project.view.pixelRatio,
                strokeCap: 'round',
                strokeJoin: 'round',
                strokeColor: backgroundColor
            })
            tmpGroup = new Group({
                children: topLayer.removeChildren(),
                blendMode: 'source-out',
                insert: false
            })
            mask = new Group({
                children: [erasePath, tmpGroup],
                blendMode: 'source-over'
            })
        }
        eraseTool.onMouseDrag = function(event) {
            console.log("erasing")
            erasePath.add(event.point)

        }
        eraseTool.onMouseUp = function(event) {
            if (erasePath.segments.length > 0) {
                erasePath.simplify()
                var eraseRadius = (strokeWidth * view.pixelRatio) / 2
                var outerPath = OffsetUtils.offsetPath(erasePath, eraseRadius)
                var innerPath = OffsetUtils.offsetPath(erasePath, -eraseRadius)
                outerPath.insert = false
                innerPath.insert = false
                innerPath.reverse() // reverse one path so we can combine them end-to-end

                // create a new path and connect the two offset paths into one shape
                var deleteShape = new Path({
                    closed: true,
                    insert: false
                })
                deleteShape.addSegments(outerPath.segments) //added to item to end path where erased
                deleteShape.addSegments(innerPath.segments)

                var endCaps = new CompoundPath({
                    children: [
                        new Path.Circle({
                            center: erasePath.firstSegment.point,
                            radius: eraseRadius
                        }),
                        new Path.Circle({
                            center: erasePath.lastSegment.point,
                            radius: eraseRadius
                        })
                    ],
                    insert: false
                })

                // // unite the shape with the endcaps
                // // this also removes all overlaps from the stroke
                deleteShape = deleteShape.unite(endCaps)
                deleteShape.simplify()

                // // grab all the items from the tmpGroup in the mask group
                var items = tmpGroup.getItems({
                    overlapping: deleteShape.bounds
                })

                items.forEach(function(item) {
                    var result = item.subtract(deleteShape, {
                        trace: false,
                        insert: false
                    }); // probably need to detect closed vs open path and tweak these settings

                    if (result.children) {
                        // if result is compoundShape, yoink the individual paths out
                        item.parent.insertChildren(item.index, result.removeChildren())
                        item.remove()
                    } else {
                        if (result.length === 0) {
                            // a fully erased path will still return a 0-length path object
                            item.remove()
                        } else {
                            item.replaceWith(result)
                        }
                    }
                })
                erasePath.remove() // done w/ this now

                topLayer.addChildren(tmpGroup.removeChildren())
                mask.remove()
            }
        }

        // Drawing Controls
        document.querySelectorAll(".pen-mode").forEach(elem => {
            elem.addEventListener("click", () => {
                penMode = elem.id;
                if (penMode === "erase") {
                    console.log(paper.tools)
                    paper.tools[1].activate()
                }
                if (penMode === "pen" || penMode === "select") {
                    paper.tools[0].activate()
                }
                if (penMode === "lasso") {
                    paper.tools[0].activate()
                        // Not sure what it does yet?
                }
                if (penMode !== "select") {
                    topLayer.getItems().forEach(path => {
                        console.log(path)
                        path.selected = false;
                    });
                }
                if (penMode !== "pen") {
                    controlPanel.style.display = "none";
                } else {
                    controlPanel.style.display = "flex";
                }
                console.log(penMode)
            });
        });


        const deletePath = () => {
            selected = getSelectedPaths();
            if (selected.length > 0) {
                pathList = selected.map(path => path.exportJSON()); //dont use paper ref
                console.log(pathList)
                undoStack.push({
                    type: 'delete-event',
                    data: pathList
                });
                selected.map(path => path.remove())
            }
            event.preventDefault();
        }

        const undo = () => {
            // pop off last path and push it onto undo stack.
            // if redo just pop off undo stack.
        }

        // Color picker
        const picker = new Picker({
            parent: document.getElementById("color-picker"),
            popup: false,
            alpha: true,
            defaultColor: '#0cf',
            editor: false,
            editorFormat: 'hex' // or 'rgb', 'hsl'
        });
        picker.setColor("#402f95");
        picker.onChange = (color) => {
            strokeColor = color.rgbaString;
        };
        document.getElementById("width-slider").oninput = function() {
            strokeWidth = parseInt(this.value, 10);
        }


        const ws = new WebSocket('ws://localhost:8000/ws');
        ws.onmessage = function(event) {
            console.log(event)
            const message = document.getElementById('message');
            const {
                type,
                content
            } = JSON.parse(event.data);
            if (type === "message") {
                message.innerHTML = content
            }
            // parse stroke information
            // if (type === "paths") {
            //     console.log(content);
            // }
        };

        const sendPrompt = (e) => {
            var input = document.getElementById("messageText")
            const msg = JSON.stringify({
                "type": "message",
                "content": input.value
            })
            ws.send(msg);
            input.value = ''
            e.preventDefault()
        }

        const sendPaths = (svgStr) => {
            const msg = JSON.stringify({
                "type": "paths",
                "content": svgStr
            })
            ws.send(msg);
        }

        document.body.addEventListener('keydown', function(event) { //delete with key
            if (event.keyCode == 8) {
                deletePath();
                event.preventDefault();
            }
            if (event.keyCode == 46) {
                deletePath();
                event.preventDefault();

            }
        });
        document.getElementById("send-prompt").addEventListener("submit", (e) => {
            sendPrompt(e)
        })
        document.getElementById("begin").addEventListener("click", () => {
            document.getElementById("sliding-overlay").style.bottom = "100%";
        });
        document.getElementById("delete").addEventListener("click", () => {
            modal.style.display = "block";
        });
        document.getElementById("cancel-modal").addEventListener("click", () => {
            modal.style.display = "none";
        });
        document.getElementById("modal-cross").addEventListener("click", () => {
            modal.style.display = "none";
        });
        document.getElementById("confirm-modal").addEventListener("click", () => {
            paper.project.clear()
            modal.style.display = "none";
        });
        document.getElementById("undo").addEventListener("click", () => {
            const lastEvent = undoStack.pop();
            if (lastEvent.type === "draw-event") {
                const removePath = lastEvent.data; //json not required
                redoStack.push({
                    type: "draw-event",
                    data: removePath.exportJSON()
                }); //so remove does not remove reference
                removePath.remove();
            }
            if (lastEvent.type === "delete-event") {
                let pathData = []
                lastEvent.data.map(redrawPath => {
                    let item = new Path();
                    item.importJSON(redrawPath);
                    pathData.push(item);
                })
                redoStack.push({
                    type: "delete-event",
                    data: pathData //use ref
                });
            }
            if (lastEvent.type === "erase-event") {

            }
        });
        document.getElementById("redo").addEventListener("click", () => {
            if (redoStack.length > 0) {
                const lastEvent = redoStack.pop();
                if (lastEvent.type === "draw-event") {
                    let item = new Path();
                    item.importJSON(lastEvent.data)
                    undoStack.push(lastEvent);
                }
                if (lastEvent.type === "delete-event") {
                    undoStack.push(lastEvent);
                    lastEvent.data.map(deletePath => {
                        deletePath.remove();
                    });
                }
                if (lastEvent.type === "erase-event") {

                }
            }
        });
    </script>
</body>

</html>