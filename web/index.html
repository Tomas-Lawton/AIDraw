<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    <link rel="stylesheet" href="style.css">
    <script src="https://unpkg.com/vanilla-picker@2"></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/paperjs/paper.js/6feff32254b6ba077d1e56d0ecf3f40be5ca594a/dist/paper-full.js"></script>
    <script type="text/javascript" src="offset.js"></script>
</head>

<body>
    <div id="modal">
        <div id="simple-modal">
            <div id="modal-status">
                <h2 id="modal-status">Clearing Canvas</h2>
                <i id="modal-cross" class="fa-solid fa-xmark"></i>
            </div>
            <p>Are you sure you want to delete your drawing? :(</p>
            <div id="action">
                <button id="cancel-modal">Cancel</button>
                <button id="confirm-modal" confirm-cancel right-button>Confirm</button>
            </div>
        </div>
    </div>

    <div id="sliding-overlay">
        <div id="hero-content">
            <h2>Welcome to Clip draw!</h2>
            <button id="begin">BEGIN</button>
        </div>
    </div>

    <div id="contain-canvas">
        <canvas id="canvas" resize></canvas>
    </div>

    <div id="clip-wrap">
        <div id="control-panel">
            <h2 id="message">Lets draw a...</h2>
            <form id="send-prompt">
                <input type="text" id="messageText" />
                <button id="draw" right-button confirm-action>DRAW</button>
            </form>
        </div>
    </div>

    <div id="art-controls">
        <div id="pen-controls">
            <div id="color-picker"></div>
            <div id="width-input">
                <label>Width</label>
                <input type="range" id="width-slider" value="20" min="1" max="40">
            </div>
        </div>

        <div id="select-controls">
            <div id="scale-input">
                <label>Scale</label>
                <input type="range" id="scale-slider" value="50" min="1" max="100">
            </div>
        </div>
    </div>

    <div id="button-panel">
        <i class="fa-solid fa-pen fa-fw pen-mode" id="pen"></i>
        <i class="fa-solid fa-arrow-pointer fa-fw pen-mode" id="select"></i>
        <i class="fa-solid fa-wand-magic-sparkles fa-fw pen-mode" id="lasso"></i>
        <i class="fa-solid fa-eraser fa-fw pen-mode" id="erase"></i>
        <i class="fa-solid fa-clock-rotate-left fa-fw" id="undo"></i>
        <i class="fa-solid fa-rotate-right fa-fw" id="redo"></i>
        <i class="fa-solid fa-left-right fa-fw" id="switch-side"></i>
        <i class="fa-solid fa-trash fa-fw" id="delete"></i>
    </div>


    <script type="text/javascript">
        // TO DO REFACTOR TOOLS.
        const ws = new WebSocket('ws://localhost:8000/ws');
        // DOES THE "FRAME" NEED TO BE MOVED?
        const targetHeight = 224;
        const canvasFrame = Math.max(window.innerWidth, window.innerHeight)
        const scaleFactor = targetHeight / canvasFrame; //take larger square so full sketch always captured
        paper.install(window);

        const modal = document.getElementById("modal");
        const canvas = document.getElementById('canvas');
        const controlPanel = document.getElementById("control-panel");
        const buttonPanel = document.getElementById("button-panel");

        const penControls = document.getElementById("pen-controls");
        const selectControls = document.getElementById("select-controls");

        const message = document.getElementById('message');
        const startCollab = document.getElementById('draw');

        const backgroundColor = "#FCFCFC"
        canvas.style.background = backgroundColor;
        const localHost = "http://localhost:8000"

        paper.setup(canvas);

        const topLayer = new Layer(); //for drawing + erase mask
        let buttonControlLeft = true;
        let strokeColor = "#402f95";
        let strokeWidth = 20;
        let myPath;
        let penMode = "pen";
        let currentSelectedPath;
        let collabDrawing = false;
        let lastRender
        undoStack = [];
        redoStack = [];

        function getSelectedPaths() {
            return topLayer.getItems().filter(path => path.selected)
        };

        const tool = new Tool();
        tool.onMouseDown = function(event) {
            if (penMode === "select") {
                path = null;
                var hitResult = paper.project.hitTest(event.point, {
                    segments: true,
                    stroke: true,
                    // tolerance: 5
                });
                if (!hitResult) {
                    topLayer.getItems().forEach(path => {
                        console.log(path)
                        path.selected = false;
                    });
                    return;
                }
                if (hitResult) {
                    path = hitResult.item;
                    path.selected = true; //fix so that this happens with no drag but with drag it won't toggle !path.selected
                }
            }
            if (penMode === "pen") {
                myPath = new Path({
                    strokeColor: strokeColor,
                    strokeWidth: strokeWidth,
                    strokeCap: 'round',
                    strokeJoin: 'round'
                });
                myPath.add(event.point);
                myPath.add({
                    ...event.point,
                    x: event.point.x + .001 //this is ok because path gets simplified
                }); //in case no drag means no line segment
            }
        }
        tool.onMouseDrag = function(event) {
            if (penMode === "pen") {
                myPath.add(event.point);
                myPath.smooth();
            }
            if (penMode === "select") {
                const selectedPaths = getSelectedPaths(); // all selected
                console.log(selectedPaths)
                selectedPaths.forEach(path => {
                    path.position.x += event.delta.x;
                    path.position.y += event.delta.y;
                })
            }
        }
        tool.onMouseUp = function(event) {
            // collabDrawing = true
            if (penMode === "pen") {
                myPath.simplify()
                    // sendPaths();
                undoStack.push({
                    type: "draw-event",
                    data: myPath
                });
            }
        }

        const eraseTool = new Tool();
        let erasePath;
        let tmpGroup;
        let mask;

        eraseTool.onMouseDown = function(event) {
            erasePath = new Path({
                strokeWidth: strokeWidth * view.pixelRatio,
                strokeCap: 'round',
                strokeJoin: 'round',
                strokeColor: backgroundColor
            })
            tmpGroup = new Group({
                children: topLayer.removeChildren(),
                blendMode: 'source-out',
                insert: false
            })
            mask = new Group({
                children: [erasePath, tmpGroup],
                blendMode: 'source-over'
            })
        }
        eraseTool.onMouseDrag = function(event) {
            console.log("erasing")
            erasePath.add(event.point)

        }
        eraseTool.onMouseUp = function(event) {
            if (erasePath.segments.length > 0) {
                erasePath.simplify()
                var eraseRadius = (strokeWidth * view.pixelRatio) / 2
                var outerPath = OffsetUtils.offsetPath(erasePath, eraseRadius)
                var innerPath = OffsetUtils.offsetPath(erasePath, -eraseRadius)
                outerPath.insert = false
                innerPath.insert = false
                innerPath.reverse() // reverse one path so we can combine them end-to-end

                // create a new path and connect the two offset paths into one shape
                var deleteShape = new Path({
                    closed: true,
                    insert: false
                })
                deleteShape.addSegments(outerPath.segments) //added to item to end path where erased
                deleteShape.addSegments(innerPath.segments)

                var endCaps = new CompoundPath({
                    children: [
                        new Path.Circle({
                            center: erasePath.firstSegment.point,
                            radius: eraseRadius
                        }),
                        new Path.Circle({
                            center: erasePath.lastSegment.point,
                            radius: eraseRadius
                        })
                    ],
                    insert: false
                })

                // // unite the shape with the endcaps
                // // this also removes all overlaps from the stroke
                deleteShape = deleteShape.unite(endCaps)
                deleteShape.simplify()

                // // grab all the items from the tmpGroup in the mask group
                var items = tmpGroup.getItems({
                    overlapping: deleteShape.bounds
                })

                items.forEach(function(item) {
                    var result = item.subtract(deleteShape, {
                        trace: false,
                        insert: false
                    }); // probably need to detect closed vs open path and tweak these settings

                    if (result.children) {
                        // if result is compoundShape, yoink the individual paths out
                        item.parent.insertChildren(item.index, result.removeChildren())
                        item.remove()
                    } else {
                        if (result.length === 0) {
                            // a fully erased path will still return a 0-length path object
                            item.remove()
                        } else {
                            item.replaceWith(result)
                        }
                    }
                })
                erasePath.remove() // done w/ this now

                topLayer.addChildren(tmpGroup.removeChildren())
                mask.remove()
            }
        }

        // Drawing Controls
        document.querySelectorAll(".pen-mode").forEach(elem => {
            elem.addEventListener("click", () => {
                penMode = elem.id;
                // REFACTOR Into a switch
                if (penMode === "erase") {
                    console.log(paper.tools)
                    paper.tools[1].activate()
                }
                if (penMode === "pen") {
                    penControls.style.display = "block";
                    paper.tools[0].activate()
                }
                if (penMode === "select") {
                    selectControls.style.display = "block";
                    paper.tools[0].activate()
                }
                if (penMode === "lasso") {
                    paper.tools[0].activate()
                        // Not sure what it does yet?
                }
                if (penMode !== "select") {
                    topLayer.getItems().forEach(path => {
                        console.log(path)
                        path.selected = false;
                    });
                }
                if (penMode !== "pen") {
                    penControls.style.display = "none";
                }
                if (penMode !== "select") {
                    selectControls.style.display = "none";
                }
                console.log(penMode)
            });
        });



        ws.onmessage = function(event) {
            if (collabDrawing) {
                if (lastRender) {
                    lastRender.remove();
                }
                let loadedSvg = topLayer.importSVG(event.data)
                loadedSvg.position.x = window.innerWidth / 2;
                loadedSvg.position.y = window.innerHeight / 2
                loadedSvg.scale(1 / scaleFactor) // invert for reading back
                lastRender = loadedSvg;
                console.log(loadedSvg)
            }
        };

        async function getPathData() {
            return fetch(localHost + "/" + 'get_latest_paths')
                .then(response => response.json())
                .catch(err => console.log(err));
        }

        async function collabDraw(url = '', requestData) {
            return fetch(url, {
                    method: "POST",
                    body: JSON.stringify(requestData),
                    cache: 'no-cache',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                })
                .then(response => response.json())
                .catch(err => console.log(err));
        }

        const pathRenderer = () => {
            // get new path data by opening for connections
            getPathData().then(data => {
                if (collabDrawing) {
                    if (lastRender) {
                        lastRender.remove();
                    }
                }
                console.log("Polling paths")
                let loadedSvg = topLayer.importSVG(data.svg)
                loadedSvg.position.x = window.innerWidth / 2;
                loadedSvg.position.y = window.innerHeight / 2
                loadedSvg.scale(1 / scaleFactor) // invert for reading back
                lastRender = loadedSvg;
            })
        }

        const deletePath = () => {
            selected = getSelectedPaths();
            if (selected.length > 0) {
                pathList = selected.map(path => path.exportJSON()); //dont use paper ref
                console.log(pathList)
                undoStack.push({
                    type: 'delete-event',
                    data: pathList
                });
                selected.map(path => path.remove())
            }
            event.preventDefault();
        }

        document.body.addEventListener('keydown', function(event) { //delete with key
            if (event.keyCode == 8) {
                deletePath();
                event.preventDefault();
            }
            if (event.keyCode == 46) {
                deletePath();
                event.preventDefault();
            }
        });
        document.getElementById("send-prompt").addEventListener("submit", (e) => {
            e.preventDefault();
            var input = document.getElementById("messageText");
            if (!collabDrawing) {
                if (input.value !== "") {
                    startCollab.innerHTML = "STOP";
                    collabDrawing = true;
                    ws.send("status");
                }
            } else {
                startCollab.innerHTML = "DRAW";
                collabDrawing = false;
                ws.send("stop");
            }
            if (input.value !== "") {
                pathData = project.exportSVG({
                    asString: true
                });
                const request = {
                    "prompt": input.value,
                    "svg": pathData
                };

                collabDraw(localHost + "/update_prompt", request)
                    .then(data => {
                        console.log(data)
                        message.innerHTML = data.data.prompt;
                        // setTimeout(setInterval(pathRenderer, 2000), 2000)
                        // get the paths 
                        // pathRenderer();
                        // setInterval(pathRenderer, 2000)

                    });
                input.value = ''
            };
        });
        document.getElementById("begin").addEventListener("click", () => {
            document.getElementById("sliding-overlay").style.bottom = "100%";
        });
        document.getElementById("delete").addEventListener("click", () => {
            modal.style.display = "block";
        });
        document.getElementById("cancel-modal").addEventListener("click", () => {
            modal.style.display = "none";
        });
        document.getElementById("modal-cross").addEventListener("click", () => {
            modal.style.display = "none";
        });
        document.getElementById("confirm-modal").addEventListener("click", () => {
            topLayer.clear()
            modal.style.display = "none";
        });
        document.getElementById("switch-side").addEventListener("click", () => {
            if (buttonControlLeft) {
                console.log(window.innerWidth)
                buttonPanel.style.left = `${window.innerWidth - buttonPanel.offsetWidth}px`;
            } else {
                buttonPanel.style.left = 0;
            }
            buttonControlLeft = !buttonControlLeft;

        });
        document.getElementById("undo").addEventListener("click", () => {
            if (redoStack.length > 0) {
                const lastEvent = undoStack.pop();
                if (lastEvent.type === "draw-event") {
                    let thisPath; //json from redo, otherwise path
                    try {
                        let temp = new Path();
                        thisPath = temp.importJSON(lastEvent.data);
                    } catch (e) {
                        thisPath = lastEvent.data;
                    }
                    let copy = thisPath.exportJSON();
                    redoStack.push({
                        type: "draw-event",
                        data: copy
                    }); //so remove does not remove reference
                    thisPath.remove();

                }
                if (lastEvent.type === "delete-event") {
                    let pathData = []
                    lastEvent.data.map(redrawPath => {
                        let thisPath = new Path();
                        thisPath = thisPath.importJSON(redrawPath);
                        pathData.push(thisPath);
                    })
                    redoStack.push({
                        type: "delete-event",
                        data: pathData //use ref
                    });
                }
                if (lastEvent.type === "erase-event") {
                    // TO DO
                }
            }
        });
        document.getElementById("redo").addEventListener("click", () => {
            if (redoStack.length > 0) {
                const lastEvent = redoStack.pop();
                if (lastEvent.type === "draw-event") {
                    let item = new Path();
                    item.importJSON(lastEvent.data)
                    undoStack.push(lastEvent);
                }
                if (lastEvent.type === "delete-event") {
                    let pathList = [];
                    lastEvent.data.map(deletePath => {
                        let pathCopy = deletePath.exportJSON();
                        deletePath.remove();
                        pathList.push(pathCopy);
                    });
                    undoStack.push({
                        type: "delete-event",
                        data: pathList
                    }); // need to store a json to redraw
                }
                if (lastEvent.type === "erase-event") {
                    // TO DO
                }
            }
        });
        document.getElementById("width-slider").oninput = function() {
            strokeWidth = parseInt(this.value, 10);
        };
        document.getElementById("scale-slider").oninput = function() {
            let newScale = parseInt(this.value, 10);
            let selected = getSelectedPaths();
            selected.scale(newScale);
        };
        // Color picker
        const picker = new Picker({
            parent: document.getElementById("color-picker"),
            popup: false,
            alpha: true,
            defaultColor: '#0cf',
            editor: false,
            editorFormat: 'hex' // or 'rgb', 'hsl'
        });
        picker.setColor("#402f95");
        picker.onChange = (color) => {
            strokeColor = color.rgbaString;
        };
    </script>
</body>

</html>